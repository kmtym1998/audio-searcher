package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"audio-searcher/api/graph/model"
	"audio-searcher/api/middleware"
	"audio-searcher/pkg/elasticsearch"
	"context"
	"encoding/json"

	"github.com/kmtym1998/es-indexer/node"
	"github.com/samber/lo"

	"github.com/cockroachdb/errors"
)

// AudioFileNodes is the resolver for the audioFileNodes field.
func (r *queryResolver) AudioFileNodes(ctx context.Context, or []*model.QueryInput, and []*model.QueryInput, limit *int, offset *int) ([]*model.AudioFileNode, error) {
	l := middleware.LoggerFrom(ctx)

	b, err := r.esClient.Search(ctx, "audio_files", elasticsearch.QueryRoot{})
	if err != nil {
		err = errors.Wrap(err, "failed to search audio file")
		l.Error(err.Error(), err)

		return nil, err
	}

	var esResp elasticsearch.ResponseRoot[node.AudioFile]
	if err := json.Unmarshal(b, &esResp); err != nil {
		err = errors.Wrap(err, "failed to unmarshal response")
		l.Error(err.Error(), err)

		return nil, err
	}

	return lo.Map(
		esResp.Hits.Items,
		func(
			item elasticsearch.Item[node.AudioFile],
			_ int,
		) *model.AudioFileNode {
			return &model.AudioFileNode{
				ID:              item.Source.NodeIdentifier(),
				FilePath:        item.Source.FilePath,
				FileName:        item.Source.FileName,
				Artists:         item.Source.Artists,
				Album:           item.Source.Album,
				AlbumArtist:     item.Source.AlbumArtist,
				Title:           item.Source.Title,
				Tags:            item.Source.Tags,
				ContainedTracks: item.Source.ContainedTracks,
			}
		},
	), nil
}
