package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"audio-searcher/api/graph/model"
	"audio-searcher/api/middleware"
	"audio-searcher/pkg/elasticsearch"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"os"

	e "github.com/cockroachdb/errors"
	"github.com/dhowden/tag"
	"github.com/kmtym1998/es-indexer/node"
	"github.com/samber/lo"
	"golang.org/x/exp/slog"
)

// AudioFileNodes is the resolver for the audioFileNodes field.
func (r *queryResolver) AudioFileNodes(ctx context.Context, or *model.AudioFileNodeQueryInput, and *model.AudioFileNodeQueryInput, limit *int, offset *int) ([]*model.AudioFileNode, error) {
	l := middleware.LoggerFrom(ctx)
	q := elasticsearch.QueryRoot{
		Size: limit,
		From: offset,
		Query: &elasticsearch.Query{
			Bool: &elasticsearch.Bool{},
		},
	}

	if or != nil {
		q.Query.Bool.Should = or.ToQueryList()
	}

	if and != nil {
		q.Query.Bool.Must = and.ToQueryList()
	}

	l.Debug("elasticsearch", slog.Any("query", q.ToString()))

	b, err := r.esClient.Search(ctx, "audio_files", q)
	if err != nil {
		err = e.Wrap(err, "failed to search audio file")
		l.Error(err.Error(), err)

		return nil, err
	}

	var esResp elasticsearch.ResponseRoot[node.AudioFile]
	if err := json.Unmarshal(b, &esResp); err != nil {
		err = e.Wrapf(err, "failed to unmarshal response from elasticsearch: %s", string(b))
		l.Error(err.Error(), err)

		return nil, err
	}

	return lo.Map(
		esResp.Hits.Items,
		func(
			item elasticsearch.Item[node.AudioFile],
			_ int,
		) *model.AudioFileNode {
			return &model.AudioFileNode{
				ID:              item.Source.NodeIdentifier(),
				FilePath:        item.Source.FilePath,
				FileName:        item.Source.FileName,
				Artists:         item.Source.Artists,
				Album:           item.Source.Album,
				AlbumArtist:     item.Source.AlbumArtist,
				Title:           item.Source.Title,
				Tags:            item.Source.Tags,
				ContainedTracks: item.Source.ContainedTracks,
			}
		},
	), nil
}

// AudioCoverArt is the resolver for the audioCoverArt field.
func (r *queryResolver) AudioCoverArt(ctx context.Context, filePath string) (model.AudioCoverArtResult, error) {
	f, err := os.Open(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			return model.AudioCoverArtErrorFileDoesNotExist{
				Code:    http.StatusText(http.StatusNotFound),
				Message: fmt.Sprintf("file '%s' does not exist", filePath),
			}, nil
		}

		return nil, e.Wrap(err, "failed to open file")
	}

	meta, err := tag.ReadFrom(f)
	if err != nil {
		return nil, e.Wrap(err, "failed to read metadata from file")
	}

	if meta.Picture() == nil || len(meta.Picture().Data) == 0 {
		return model.AudioCoverArtErrorDoesNotHaveCover{
			Code:    http.StatusText(http.StatusNotFound),
			Message: "no cover art",
		}, nil
	}

	return model.AudioCoverArtSuccess{
		Base64Img: base64.StdEncoding.EncodeToString(meta.Picture().Data),
	}, nil
}
